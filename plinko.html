<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Plinko Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="css/plinko.css">
</head>
<body>
    <div class="game-container">
        <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
        <div class="top-panel">
            <div class="close-btn" onclick="goBack()">
                <span>‚Üê</span>
            </div>
            <div class="top-right">
                <div class="balance">
                    <i class="bi bi-currency-exchange"></i>
                    <span id="balance">0.00</span>
                    <button class="balance-plus-btn" onclick="openDepositModal()">
                        <i class="bi bi-plus"></i>
                    </button>
                </div>
                <div id="demo-badge">DEMO</div>
            </div>
        </div>

        <!-- –ö–æ–Ω—Ç–µ–Ω—Ç Plinko -->
        <div class="plinko-content">
            <div class="plinko-title">
                <span class="title-icon">üéØ</span>
                Plinko
            </div>
            
            <!-- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ -->
            <div class="plinko-game">
                <canvas id="plinko-canvas"></canvas>
                
                <!-- –ú–Ω–æ–∂–∏—Ç–µ–ª–∏ -->
                <div class="plinko-multipliers" id="multipliers">
                    <div class="multiplier high-mult" data-mult="5.8" data-index="0">
                        <span class="mult-value">x5.8</span>
                    </div>
                    <div class="multiplier medium-mult" data-mult="2.2" data-index="1">
                        <span class="mult-value">x2.2</span>
                    </div>
                    <div class="multiplier low-mult" data-mult="1.1" data-index="2">
                        <span class="mult-value">x1.1</span>
                    </div>
                    <div class="multiplier low-mult" data-mult="1.1" data-index="3">
                        <span class="mult-value">x1.1</span>
                    </div>
                    <div class="multiplier minimal-mult" data-mult="0.4" data-index="4">
                        <span class="mult-value">x0.4</span>
                    </div>
                    <div class="multiplier low-mult" data-mult="1.1" data-index="5">
                        <span class="mult-value">x1.1</span>
                    </div>
                    <div class="multiplier low-mult" data-mult="1.1" data-index="6">
                        <span class="mult-value">x1.1</span>
                    </div>
                    <div class="multiplier medium-mult" data-mult="2.2" data-index="7">
                        <span class="mult-value">x2.2</span>
                    </div>
                    <div class="multiplier high-mult" data-mult="5.8" data-index="8">
                        <span class="mult-value">x5.8</span>
                    </div>
                </div>
            </div>
            
            <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
            <div class="plinko-controls">
                <div class="bet-controls">
                    <div class="bet-input-group">
                        <label for="bet-amount">–°—Ç–∞–≤–∫–∞ (TON):</label>
                        <div class="input-wrapper">
                            <input type="number" id="bet-amount" value="1.0" min="0.1" step="0.1" max="100">
                        </div>
                    </div>
                    <div class="balance-info">
                        –ë–∞–ª–∞–Ω—Å: <span id="current-balance">0.00</span> TON
                    </div>
                    <button class="drop-ball-btn" onclick="dropBall()">
                        <span class="btn-text">üéØ –ö–∏–Ω—É—Ç—å —à–∞—Ä–∏–∫</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞ -->
    <div id="deposit-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üí∞ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å</h3>
                <span class="close" onclick="closeDepositModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="input-group">
                    <label for="deposit-amount">–°—É–º–º–∞ (TON):</label>
                    <input type="number" id="deposit-amount" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É" min="1" step="0.01">
                </div>
                <button class="modal-btn deposit-btn" onclick="processDeposit()">–ü–æ–ø–æ–ª–Ω–∏—Ç—å</button>
            </div>
        </div>
    </div>

    <!-- –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ -->
    <div id="result-notification" class="notification" style="display: none;">
        <div class="notification-content">
            <span id="notification-message"></span>
        </div>
    </div>

    <script>
        let currentUser = null;
        let isDemoMode = false;
        let activeBalls = 0;
        let plinkoGame;

        class OptimizedPlinko {
            constructor() {
                this.canvas = document.getElementById('plinko-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.pins = [];
                this.balls = [];
                this.particlePool = [];
                this.isAnimating = false;
                this.balance = 0;
                
                this.setupCanvas();
                this.createPins();
                this.bindEvents();
            }
            
            setupCanvas() {
                const container = this.canvas.parentElement;
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = 450 * dpr;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = '450px';
                
                this.ctx.scale(dpr, dpr);
                this.canvasWidth = rect.width;
                this.canvasHeight = 450;
            }
            
            createPins() {
                this.pins = [];
                const rows = 12;
                const pinRadius = window.innerWidth < 500 ? 3 : 4;
                const rowHeight = window.innerWidth < 500 ? 28 : 35;
                
                for (let row = 2; row < rows; row++) {
                    const pinsInRow = row + 1;
                    const spacing = this.canvasWidth / (pinsInRow + 1);
                    const y = 50 + row * rowHeight;
                    
                    for (let col = 0; col < pinsInRow; col++) {
                        const x = spacing * (col + 1);
                        this.pins.push({
                            x: x,
                            y: y,
                            radius: pinRadius,
                            glowTime: 0
                        });
                    }
                }
            }
            
            bindEvents() {
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.createPins();
                });
            }
            
            createBall(targetSlot) {
                const ball = {
                    x: this.canvasWidth / 2,
                    y: 30,
                    vx: 0,
                    vy: 0,
                    radius: window.innerWidth < 500 ? 8 : 10,
                    targetSlot: targetSlot,
                    trail: []
                };
                
                this.balls.push(ball);
                
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animate();
                }
            }
            
            animate() {
                if (!this.isAnimating) return;
                
                // –û—á–∏—Å—Ç–∫–∞ canvas —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
                this.ctx.fillStyle = 'rgba(15, 20, 35, 0.95)';
                this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                
                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —à—Ç–∏—Ñ—Ç–æ–≤
                this.drawPins();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —à–∞—Ä–∏–∫–æ–≤
                for (let i = this.balls.length - 1; i >= 0; i--) {
                    const ball = this.balls[i];
                    this.updateBall(ball);
                    this.drawBall(ball);
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –Ω–∏–∑–∞
                    if (ball.y > this.canvasHeight - 80) {
                        this.finalizeBall(ball);
                        this.balls.splice(i, 1);
                    }
                }
                
                // –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                if (this.balls.length > 0) {
                    requestAnimationFrame(() => this.animate());
                } else {
                    this.isAnimating = false;
                }
            }
            
            updateBall(ball) {
                // –§–∏–∑–∏–∫–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
                ball.vy += 0.4; // –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                ball.vx *= 0.998; // —Ç—Ä–µ–Ω–∏–µ
                ball.vy *= 0.998;
                
                ball.x += ball.vx;
                ball.y += ball.vy;
                
                // –ì—Ä–∞–Ω–∏—Ü—ã
                if (ball.x < ball.radius) {
                    ball.x = ball.radius;
                    ball.vx = Math.abs(ball.vx) * 0.7;
                }
                if (ball.x > this.canvasWidth - ball.radius) {
                    ball.x = this.canvasWidth - ball.radius;
                    ball.vx = -Math.abs(ball.vx) * 0.7;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å —à—Ç–∏—Ñ—Ç–∞–º–∏
                for (let pin of this.pins) {
                    const dx = pin.x - ball.x;
                    const dy = pin.y - ball.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < pin.radius + ball.radius) {
                        // –û—Ç—Å–∫–æ–∫
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        ball.vx = -cos * speed * 0.8 + (Math.random() - 0.5) * 2;
                        ball.vy = -sin * speed * 0.8;
                        
                        // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è —à—Ç–∏—Ñ—Ç–∞
                        pin.glowTime = 10;
                        
                        // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–µ–º —à–∞—Ä–∏–∫ –æ—Ç —à—Ç–∏—Ñ—Ç–∞
                        const pushDistance = pin.radius + ball.radius;
                        ball.x = pin.x - cos * pushDistance;
                        ball.y = pin.y - sin * pushDistance;
                        
                        // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
                        this.createCollisionSpark(pin.x, pin.y);
                        
                        break;
                    }
                }
                
                // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ª–µ–¥
                ball.trail.push({ x: ball.x, y: ball.y });
                if (ball.trail.length > 8) {
                    ball.trail.shift();
                }
            }
            
            drawPins() {
                for (let pin of this.pins) {
                    // –£–º–µ–Ω—å—à–∞–µ–º —Å–≤–µ—á–µ–Ω–∏–µ
                    if (pin.glowTime > 0) {
                        pin.glowTime--;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.arc(pin.x, pin.y, pin.radius, 0, Math.PI * 2);
                    
                    if (pin.glowTime > 0) {
                        // –°–≤–µ—Ç—è—â–∏–π—Å—è —ç—Ñ—Ñ–µ–∫—Ç –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏
                        const glowIntensity = pin.glowTime / 10;
                        this.ctx.fillStyle = `rgba(255, 200, 0, ${glowIntensity})`;
                        this.ctx.shadowColor = '#ffc800';
                        this.ctx.shadowBlur = 15 * glowIntensity;
                    } else {
                        this.ctx.fillStyle = '#e8e8e8';
                        this.ctx.shadowBlur = 0;
                    }
                    
                    this.ctx.fill();
                    this.ctx.shadowBlur = 0;
                }
            }
            
            drawBall(ball) {
                // –†–∏—Å—É–µ–º —Å–ª–µ–¥
                for (let i = 0; i < ball.trail.length; i++) {
                    const point = ball.trail[i];
                    const alpha = (i + 1) / ball.trail.length * 0.3;
                    const size = ball.radius * 0.5 * alpha;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(255, 149, 0, ${alpha})`;
                    this.ctx.fill();
                }
                
                // –†–∏—Å—É–µ–º —à–∞—Ä–∏–∫
                this.ctx.beginPath();
                this.ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                
                // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –æ–±—ä–µ–º–Ω–æ—Å—Ç–∏
                const gradient = this.ctx.createRadialGradient(
                    ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                    ball.x, ball.y, ball.radius
                );
                gradient.addColorStop(0, '#ffdb4d');
                gradient.addColorStop(0.7, '#ff9500');
                gradient.addColorStop(1, '#cc7400');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fill();
                
                // –°–≤–µ—á–µ–Ω–∏–µ
                this.ctx.shadowColor = '#ff9500';
                this.ctx.shadowBlur = 15;
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
            
            createCollisionSpark(x, y) {
                // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –∏—Å–∫—Ä—ã –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏
                for (let i = 0; i < 3; i++) {
                    const spark = document.createElement('div');
                    spark.className = 'collision-spark';
                    spark.style.left = x + 'px';
                    spark.style.top = y + 'px';
                    document.body.appendChild(spark);
                    
                    setTimeout(() => spark.remove(), 250);
                }
            }
            
            finalizeBall(ball) {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤ –∫–∞–∫–æ–π —Å–ª–æ—Ç –ø–æ–ø–∞–ª —à–∞—Ä–∏–∫
                const slotWidth = this.canvasWidth / 9;
                const slot = Math.max(0, Math.min(8, Math.floor(ball.x / slotWidth)));
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –º–Ω–æ–∂–∏—Ç–µ–ª—è
                const multipliers = document.querySelectorAll('.multiplier');
                const targetMultiplier = multipliers[slot];
                const mult = parseFloat(targetMultiplier.dataset.mult);
                
                targetMultiplier.classList.add('multiplier-win');
                setTimeout(() => {
                    targetMultiplier.classList.remove('multiplier-win');
                }, 800);
                
                activeBalls--;
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            plinkoGame = new OptimizedPlinko();
        });

        function initializeGame() {
            const tg = window.Telegram.WebApp;
            if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
                currentUser = {
                    id: tg.initDataUnsafe.user.id,
                    username: tg.initDataUnsafe.user.username || `User_${tg.initDataUnsafe.user.id}`
                };
                loadUserData();
            } else {
                // –î–µ–º–æ —Ä–µ–∂–∏–º –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                isDemoMode = true;
                updateBalanceDisplay(1000);
                document.getElementById('demo-badge').style.display = 'block';
            }
        }

        async function loadUserData() {
            try {
                const response = await fetch(`/api/user/balance/${currentUser.id}`);
                if (response.ok) {
                    const userData = await response.json();
                    const balance = userData.demo_mode ? userData.demo_balance : userData.main_balance;
                    updateBalanceDisplay(balance);
                    isDemoMode = userData.demo_mode;
                    document.getElementById('demo-badge').style.display = isDemoMode ? 'block' : 'none';
                }
            } catch (error) {
                console.error('Error loading user data:', error);
                // Fallback –Ω–∞ –¥–µ–º–æ —Ä–µ–∂–∏–º
                isDemoMode = true;
                updateBalanceDisplay(1000);
                document.getElementById('demo-badge').style.display = 'block';
            }
        }

        function updateBalanceDisplay(balance) {
            document.getElementById('balance').textContent = balance.toFixed(2);
            document.getElementById('current-balance').textContent = balance.toFixed(2);
        }

        function goBack() {
            window.location.href = 'index.html';
        }

        // –ü–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —Å 60 FPS
        async function dropBall() {
            const betAmount = parseFloat(document.getElementById('bet-amount').value);
            if (betAmount < 0.1 || betAmount > 100) {
                showNotification('–°—Ç–∞–≤–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 0.1 –¥–æ 100 TON', 'error');
                return;
            }

            const currentBalance = parseFloat(document.getElementById('current-balance').textContent);
            if (currentBalance < betAmount) {
                showNotification('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤', 'error');
                return;
            }

            updateBalanceDisplay(currentBalance - betAmount);

            if (isDemoMode || !currentUser) {
                // –î–µ–º–æ —Ä–µ–∂–∏–º - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ª–æ–∫–∞–ª—å–Ω–æ
                const weights = [0.02, 0.08, 0.15, 0.25, 0.25, 0.25, 0.15, 0.08, 0.02];
                const random = Math.random();
                let sum = 0;
                let targetSlot = 4;
                
                for (let i = 0; i < weights.length; i++) {
                    sum += weights[i];
                    if (random <= sum) {
                        targetSlot = i;
                        break;
                    }
                }

                const multipliers = [5.8, 2.2, 1.1, 1.1, 0.4, 1.1, 1.1, 2.2, 5.8];
                const multiplier = multipliers[targetSlot];
                const winAmount = betAmount * multiplier;
                const newBalance = currentBalance - betAmount + winAmount;
                
                setTimeout(() => {
                    updateBalanceDisplay(newBalance);
                    
                    if (multiplier > 1) {
                        showNotification(`–í—ã–∏–≥—Ä—ã—à: ${winAmount.toFixed(2)} TON! (x${multiplier})`, 'success');
                        if (multiplier >= 2) {
                            createWinEffect(document.querySelectorAll('.multiplier')[targetSlot]);
                        }
                    } else {
                        showNotification(`–ü—Ä–æ–∏–≥—Ä—ã—à: x${multiplier}`, 'error');
                    }
                }, 3000);
                
                plinkoGame.createBall(targetSlot);
                return;
            }

            try {
                const response = await fetch('/api/plinko/drop', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        telegramId: currentUser.id,
                        betAmount: betAmount,
                        demoMode: isDemoMode
                    })
                });

                const result = await response.json();

                if (result.success) {
                    plinkoGame.createBall(result.slot_index);
                    
                    setTimeout(() => {
                        updateBalanceDisplay(result.new_balance);
                        
                        if (result.win_amount > 0) {
                            showNotification(`–í—ã–∏–≥—Ä—ã—à: ${result.win_amount.toFixed(2)} TON! (x${result.multiplier})`, 'success');
                            if (result.multiplier >= 2) {
                                createWinEffect(document.querySelectorAll('.multiplier')[result.slot_index]);
                            }
                        } else {
                            showNotification(`–ü—Ä–æ–∏–≥—Ä—ã—à: x${result.multiplier}`, 'error');
                        }
                    }, 3000);
                } else {
                    showNotification('–û—à–∏–±–∫–∞: ' + result.error, 'error');
                    updateBalanceDisplay(currentBalance);
                }
            } catch (error) {
                console.error('Drop error:', error);
                showNotification('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'error');
                updateBalanceDisplay(currentBalance);
            }
        }

        function createWinEffect(element) {
            const rect = element.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top;
            
            for (let i = 0; i < 12; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'win-particle';
                    particle.style.left = x + (Math.random() - 0.5) * 60 + 'px';
                    particle.style.top = y + 'px';
                    document.body.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 1000);
                }, i * 30);
            }
        }

        function showNotification(message, type) {
            const notification = document.getElementById('result-notification');
            const messageEl = document.getElementById('notification-message');
            
            messageEl.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        // –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞
        function openDepositModal() {
            document.getElementById('deposit-modal').style.display = 'block';
        }

        function closeDepositModal() {
            document.getElementById('deposit-modal').style.display = 'none';
            document.getElementById('deposit-amount').value = '';
        }

        async function processDeposit() {
            const amount = parseFloat(document.getElementById('deposit-amount').value);
            
            if (!amount || amount < 1) {
                showNotification('–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 1 TON', 'error');
                return;
            }
            
            if (isDemoMode) {
                // –í –¥–µ–º–æ —Ä–µ–∂–∏–º–µ –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –∫ –±–∞–ª–∞–Ω—Å—É
                const currentBalance = parseFloat(document.getElementById('current-balance').textContent);
                updateBalanceDisplay(currentBalance + amount);
                closeDepositModal();
                showNotification(`–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ ${amount} TON`, 'success');
                return;
            }

            try {
                const response = await fetch('/api/user/deposit', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        telegramId: currentUser.id,
                        amount: amount,
                        demoMode: isDemoMode
                    })
                });

                const result = await response.json();

                if (result.success) {
                    updateBalanceDisplay(result.new_balance);
                    closeDepositModal();
                    showNotification(`–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ ${amount} TON`, 'success');
                } else {
                    showNotification('–û—à–∏–±–∫–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Deposit error:', error);
                showNotification('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'error');
            }
        }

        // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ø–æ –∫–ª–∏–∫—É –≤–Ω–µ –µ–≥–æ
        window.onclick = function(event) {
            const modal = document.getElementById('deposit-modal');
            if (event.target == modal) {
                closeDepositModal();
            }
        }
    </script>
</body>
</html>